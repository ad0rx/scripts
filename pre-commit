#!/usr/bin/env perl
# pre-commit
#
# Run this script to scan for warnings and errors in RTL that I am
# responsible for before committing to git
#
#
#
# For now, given a list of files, create a single output file
# containing all warnings linked to files under security/
#
# > pre-commit log1 log2 ... logN
#
######################################################################
# TODO
# Pre-filter each log file for "Warning" string to reduce input data
#
#
######################################################################
use warnings;
use diagnostics;
use strict;
use v5.26;
use POSIX ":sys_wait_h";

my $PWS = $ENV{'PWS'};
my $TMP_FILE0 = "pre-commit-tmp0";
my $TMP_FILE1 = "pre-commit-tmp1";
my $TMP_FILE2 = "pre-commit-final";

#chomp ($a = <STDIN>);
#say $a;

#my @lines = `ls -lah`;
#foreach (@lines) {
#  s/f/BRAD/g;
#  print;
#}

#my @lines = <STDIN>;
#print @lines;

######################################################################
# Run stb
# run bdtb
# once bdtb has created vivado project fork vivado
# when bdtb and vivado done, check logs
######################################################################
# Run stb

# cd to dir
#> stb | tee stb_out
# run simulation
# wait for sim to finish
# grep for warnings and save to file
# grep warnings for security rtl files save to another file
# view this file, fix issues

# Run bdtb
# cd to dir
# run bdtb | bdtb_out
# run simulation
# wait for sim to finish

# grep for warnings and save to file
#> grep -A1 -B3 -i warn bdtb_out | tee bdtb_warn
# for f in $PWS/FPGA/security/hdl/*; do grep -C3 `basename $f` bdtb_warn; done | tee security_warn

# grep warnings for security rtl files save to another file
# view this file, fix issues

# Run the Vivado TB
# this one last because takes longest and is most permissive
# git clean -fxd
# cd to dir
# run vivado to recreate_project.tcl
# select top module
# run simulation
# wait for sim to finish
# grep for warnings and save to file
# grep warnings for security rtl files save to another file
# view this file, fix issues
# Grep for warnings and errors with security files

# Grep for warnings and errors with security files

# Report if clean

# Generalized Flow
#
# cd to a dir
# run a command, capture output
# grep output files for warnings and errors
# grep that file for security rtl files
# view output, or report clean
# go to next step


# Kick off the vivado and questa simulations in parallel
# Inputs
# Working dir
#  this is the dir where vivado and bdtb will be launched from
#
sub run_simulations {

    my ($work_dir) = @_;

    # CD to a dir
    print ("work_dir: $work_dir\n");

    chdir ("$work_dir");

    print ("about to fork\n");

    # Fork bdtb build
    # do this one first because bdtb automatically deletes vivado dir
    my $pid2 = fork ();
    unless ($pid2) {
        print ("Running Questa Simulation\n");
        system("bdtb > bdtb_out");
        print ("Questa Simulation Complete\n");
        exit();
    }

    # Fork Vivado Build
    my $pid1 = fork ();
    unless ($pid1) {
        print ("Running Vivado Simulation\n");
        system("vivado -nolog -nojournal -mode tcl -source \${HOME}/scripts/run_vivado_sim_top_tb.tcl > vivado_out");
        print ("Vivado Simulation Complete\n");
        exit();
    }

    # Join
    print ("waiting on pids\n");
    wait;
    wait;
    print ("done waiting\n");
}

# open file
# read a line
# look for exact string match
# on first match, write line plus next to output file
# continue to next line
#
# Inputs
# Array of Files (ref)
# Array of strings (ref)
# output file name
#
# Outputs
sub filter_file_for_strings {

    my ($inFiles, $strings, $outFile) = @_;

    foreach my $inFile (@$inFiles) {

        print ("inFile: $inFile\n");
        print ("outFile: $outFile\n");

        # Open the input file
        open (IF, '<', $inFile) or die $!;

        # Open the output file
        open (OF, '>>', $outFile) or die $!;

        # While read line
        while (<IF>) {

            # If this line has 'warning' on it, then test for strings
            if (/warning/i) {

                #print (OF "\n");

                # Test every string against this line, if match, print the
                # line to outFile
                foreach my $string (@$strings) {

                    #print (OF "$string\n");

                    # Modify string so that the '.' matches on period only
                    my $tstring = $string;
                    $tstring  =~ s/[.]/[\.]/;
                    #print (OF "$tstring\n");

                    if (/$tstring/) {

                        # Print a separator
                        print (OF "--\n");
                        print (OF "File   : $inFile\n");
                        print (OF "Matched: $tstring\n");
                        print (OF);

                        # Print the following line as well
                        my $nextLine = <IF>;
                        print (OF $nextLine);

                        #next;

                    } # end if match

                } # end foreach $string

            } # end unless
        }

        # Close input file
        close (IF);

        # Print a separator
        print (OF "-- End $inFile\n");

        # Close output file
        close (OF);

    } # end foreach inFile

    # Display final results, from all input files that were filtered
    open (OF, '<', $outFile) or die $!;
    while (<OF>) {
        print;
    }
    close(OF);

    # Delete the temporary output file
    unlink($outFile) or die "Can't delete $outFile: $!\n";
}

# Inputs
# List of Log Files
# List of Source Files
#
# Outputs
# File containing warnings from source files
sub filter_logs_for_strings {

    my $logs    = shift;
    my $strings = shift;

    #print ("Running filter_logs_for_strings\n");
    #print ("Logs   : @$logs\n");
    #print ("Strings: @$strings\n");

    # Iterate over logs
    foreach my $logFile (@$logs) {
        print ("\nLogFile: $logFile\n");
        print ("-------------------\n");

        # Consider pre-filtering the log file for "Warning" string to
        # reduce input data volume. Def create execution speedup.
        my $command = "grep -A1 -i \"warning\" $logFile >> $TMP_FILE0";
        #print ("command: $command\n");
        system($command);

        # Iterate over strings
        foreach my $string (@$strings) {
            #print ("String: $string\n");

            my $command = "grep -A1 $string $TMP_FILE0 >> $TMP_FILE1";
            #print ("command: $command\n");
            system($command);

        } # end foreach string

    } # end foreach logFile

    # Clean up final output to contain only warnings
    #my $command = "grep -A1 -i \"warning\" $TMP_FILE1 >> $TMP_FILE2";
    #print ("command: $command\n");
    #system($command);

    print ("\nResults:\n");
    #system ("cat", "$TMP_FILE2");
    system ("cat", "$TMP_FILE1");

    #system ("rm", "$TMP_FILE0");
    #system ("rm", "$TMP_FILE1");
    #system ("rm", "$TMP_FILE2");
}

# Inputs
# Path
#
# Outputs
# Array of file names
sub get_files_under_path {
    my $path = shift;
    #print ("ENTER: get_files_under_dir\n");

    #my @files = `ls -r $path`;
    my $output = `find \$PWS/FPGA/security/hdl -type f -printf "%f "`;
    my @files = split (" ", $output);
    #print ("files: @files\n");

    return @files;
}

my @logs = ("$PWS/bdtb_out", "$PWS/vivado_out");
print ("logs: @logs\n");

# Kick off the vivado and questa simulations in parallel
&run_simulations($PWS);

# Get list of log files from command line
# Get list of strings by reading security/ directory for file names
my @fileNames = &get_files_under_path ("\${PWS}/FPGA/security/hdl");
&filter_file_for_strings (\@logs, \@fileNames, $TMP_FILE0);
