#!/usr/bin/env perl
# pre-commit
#
# Run this script to scan for warnings and errors in RTL that I am
# responsible for before committing to git
# > pre-commit-screen.sh &
# > pre-commit
######################################################################
# TODO
#
# fix handler so that it still works if bdtb is already
# complete. probably have to remove bdtbh->finish call or do a check
# before calling that to make sure the process is still running
#
# Start vivado sim before bdtb because it takes longer than bdtb
#  xadd vivado output filter
#  xfixup bdtb script to comment "rmtree vivado" call
#  xrm vivado dir from this script at right time
#  make bdtb_fixed executable
#  call fixed up version
#
######################################################################
use warnings;
use diagnostics;
use strict;
use v5.26;
use POSIX ":sys_wait_h";
use File::Path 'rmtree';

# Using start() instead of system():
use IPC::Run qw( start );

my $PWS   = $ENV{'PWS'};
my $PROOT = $ENV{'PROOT'};

my $TMP_FILE0 = "pre-commit-tmp0";
my $TMP_FILE1 = "pre-commit-tmp1";
my $TMP_FILE2 = "pre-commit-final";

my $bdtb_out         = "bdtb_out";
my $vivado_out       = "vivado_out";
my $bdtb_path        = "$PWS/FPGA/BusDefenderFirst/scripts/bdtb";
my $bdtb_fixed_path  = "$PROOT/bdtb_fixed";

my $bdtbh;
my $bdtbSTDIN;
my $bdtb_using_vivado = 1;
my $vivadoh;
my $vivadoSTDIN;
my $vivado_is_building_project = 1;

# Make any preparations required before starting simulations
#
# 1. Remove existing 'vivado' working dir
sub prepare_environment {

    rmtree "$PWS/FPGA/BusDefenderFirst/vivado";

}

# Fixup the bdtb script so that it does not remove the vivado project
# directory. Do this by reading bdtb line-by-line, looking for a regex
# and then replace matching line with a commented line.
sub bdtb_fixup {

    # Open the current bdtb script
    open (IF, "<", $bdtb_path) or die "Unable to open $bdtb_path\n";
    open (OF, ">", $bdtb_fixed_path) or die "Unable to open $bdtb_fixed_path\n";
    while (<IF>) {

        # Look for the line that needs to be changed
        if (/(rmtree \"\$PWS\/FPGA\/BusDefenderFirst\/vivado\";)/) {
            print (OF "# $1 LINE COMMENTED BY pre-commit SCRIPT\n");
        } else {
            print (OF);
        } # end else

    } # end while
    close (IF);
    close (OF);

    chmod (0777, $bdtb_fixed_path);
}

# Output from bdtb arrives here and is printed to $bdtb_out as well as
# filtered to determine when the vivado build process has
# completed. This prevents a race condition between bdtb and the
# vivado simulation, which both access the sources area of the project
# to write simulation files and various other outputs
sub bdtb_out_filter {

    my $string = shift;

    # Send output to the file for later use by this script
    open  (AOF, ">>", $bdtb_out) or die "unable to open bdtb_out\n";
    print (AOF $string);
    close (AOF);

    # Filter the output to catch when vivado project build completes
    # This is a semaphore, clearing allows vivado simulation process to start
    if ($string =~ /Exiting Vivado/) {
        print ("clearing bdtb_using_vivado\n");
        $bdtb_using_vivado = 0;
    }

}

# Output from vivado arrives here and is printed to $vivado_out as well as
# filtered to determine when the vivado build process has
# completed. This prevents a race condition between bdtb and the
# vivado simulation, which both access the sources area of the project
# to write simulation files and various other outputs.
sub vivado_out_filter {

    my $string = shift;

    # Send output to the file for later use by this script
    open  (BOF, ">>", $vivado_out) or die "unable to open vivado_out\n";
    print (BOF $string);
    close (BOF);

    # Filter the output to catch when vivado project build completes
    # This is a semaphore, clearing allows vivado simulation process to start
    if ($string =~ /launch_simulation/) {
        print ("clearing vivado_is_building_project\n");
        $vivado_is_building_project = 0;
    }

}

# General signal handler for testing
sub handler {

    my $sig = shift;

    print ("Caught a signal, shutting down...: $sig\n");

    $vivadoh->signal ("INT");
    $bdtbh->signal   ("INT");

    print ("waiting for vivado to shutdown\n");
    print ("this may take about 10 seconds\n");
    $bdtbSTDIN = "exit 1\n";
    $bdtbh->pump;
    $bdtbh->finish;

    # Could make this pretty cool by printing last line of $vivado_out
    # until vivado exits, maybe
    $vivadoSTDIN = "exit 1\n";
    $vivadoh->pump;
    $vivadoh->finish;

}

# Kick off the vivado and questa simulations in parallel
# Inputs
# Working dir
#  this is the dir where vivado and bdtb will be launched from
#
sub run_simulations {

    my ($work_dir) = @_;

    # CD to a dir
    print ("work_dir: $work_dir\n");
    chdir ("$work_dir");

    # Create the output files, so that the pre-commit-screen.sh script
    # will be able to tail -f them even before the simulations have
    # begun running
    open (OF, ">", $bdtb_out );
    close (OF);
    open (OF, ">", $vivado_out);
    close (OF);

    my @cmd1 = ("pre-commit-screen.sh");
    my $screenh = start (\@cmd1);

    # Register handler so we can cancel the script if needed
    $SIG{INT} = \&handler;

    my $HOME = $ENV{"HOME"};
    my @cmd2 = ("vivado", "-notrace", "-nolog", "-nojournal", "-mode",
                "tcl", "-source",
                "$HOME/scripts/run_vivado_sim_top_tb.tcl");
    #my @cmd2 = ("vivado", "-help");

    print ("Starting vivado\n");
    #$vivadoh = start (\@cmd2, \$vivadoSTDIN, ">&", $vivado_out);
    $vivadoh = start (\@cmd2, \$vivadoSTDIN, ">&", \&vivado_out_filter);

    # Wait for bdtb to clear out of the vivado build state
    # TODO, watch bdtb_out file for signs that Vivado build has completed
    while ($vivado_is_building_project) {
        sleep 1;
        $vivadoh->pump if $vivadoh->pumpable;
    }

    print ("Starting bdtb\n");
    @cmd1 = ($bdtb_fixed_path);
    $bdtbh = start (\@cmd1, \$bdtbSTDIN, \&bdtb_out_filter);

    # Join
    print ("waiting on simulations\n");
    $bdtbh->finish;
    print ("bdtb complete\n");
    $vivadoh->finish;
    print ("vivado complete\n");
    print ("waiting on screen\n");
    $screenh->finish;
    print ("done waiting\n");
}

# open file
# read a line
# look for exact string match
# on first match, write line plus next to output file
# continue to next line
#
# Inputs
# Array of Files (ref)
# Array of strings (ref)
# output file name
#
# Outputs
sub filter_file_for_strings {

    my ($inFiles, $strings, $outFile) = @_;

    foreach my $inFile (@$inFiles) {

        print ("inFile: $inFile\n");
        print ("outFile: $outFile\n");

        # Open the input file
        open (IF, '<', $inFile) or die $!;

        # Open the output file
        open (OF, '>>', $outFile) or die $!;

        # While read line
        while (<IF>) {

            # If this line has 'warning' on it, then test for strings
            if (/warning/i) {

                #print (OF "\n");

                # Test every string against this line, if match, print the
                # line to outFile
                foreach my $string (@$strings) {

                    #print (OF "$string\n");

                    # Modify string so that the '.' matches on period only
                    my $tstring = $string;
                    $tstring  =~ s/[.]/[\.]/;
                    #print (OF "$tstring\n");

                    if (/$tstring/) {

                        # Print a separator
                        print (OF "--\n");
                        print (OF "File   : $inFile\n");
                        print (OF "Matched: $tstring\n");
                        print (OF);

                        # Print the following line as well
                        my $nextLine = <IF>;
                        print (OF $nextLine);

                        #next;

                    } # end if match

                } # end foreach $string

            } # end unless
        }

        # Close input file
        close (IF);

        # Print a separator
        print (OF "-- End $inFile\n");

        # Close output file
        close (OF);

    } # end foreach inFile

    # Display final results, from all input files that were filtered
    open (OF, '<', $outFile) or die $!;
    while (<OF>) {
        print;
    }
    close(OF);

    # Delete the temporary output file
    unlink($outFile) or die "Can't delete $outFile: $!\n";
}

# Inputs
# Path
#
# Outputs
# Array of file names
sub get_files_under_path {
    my $path = shift;
    #print ("ENTER: get_files_under_dir\n");

    #my @files = `ls -r $path`;
    my $output = `find \$PWS/FPGA/security/hdl -type f -printf "%f "`;
    my @files = split (" ", $output);
    #print ("files: @files\n");

    return @files;
}

&bdtb_fixup();
&prepare_environment();

# Kick off the vivado and questa simulations in parallel
&run_simulations($PWS);

# Get list of strings by reading security/ directory for file names
my @fileNames = &get_files_under_path ("\${PWS}/FPGA/security/hdl");

# Filter the logs
my @logs = ("$bdtb_out", "$vivado_out");
&filter_file_for_strings (\@logs, \@fileNames, $TMP_FILE0);
