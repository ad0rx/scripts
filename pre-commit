#!/usr/bin/env perl
# pre-commit
#
# Run this script to scan for warnings and errors in RTL that I am
# responsible for before committing to git
# > pre-commit-screen.sh &
# > pre-commit
######################################################################
# TODO
#
# Appears to be a race condition with bdtb and vivado sim, come up
# with a way to stall vivado sim thread until bdtb is done with vivado
# step. See IPC::Run MCPAN documentation and try to implement an
# output redirection to subroutine. Perform filtering in sub and then
# write the line to a file for later use by the rest of the script.
#
# fix handler so that it still works if bdtb is already
# complete. probably have to remove bdtbh->finish call or do a check
# before calling that to make sure the process is still running
#
######################################################################
use warnings;
use diagnostics;
use strict;
use v5.26;
use POSIX ":sys_wait_h";

## Using run() instead of system():
use IPC::Run qw( start );

my $PWS = $ENV{'PWS'};
my $TMP_FILE0 = "pre-commit-tmp0";
my $TMP_FILE1 = "pre-commit-tmp1";
my $TMP_FILE2 = "pre-commit-final";

my $bdtb_out   = "bdtb_out";
my $vivado_out = "vivado_out";
my $bdtbh;
my $bdtbSTDIN;
my $vivadoh;
my $vivadoSTDIN;

# General signal handler for testing
sub handler {

    my $sig = shift;

    print ("Caught a signal, shutting down...: $sig\n");

    $vivadoh->signal ("INT");
    $bdtbh->signal   ("INT");

    print ("waiting for vivado to shutdown\n");
    print ("this may take about 10 seconds\n");
    $bdtbSTDIN = "exit 1\n";
    $bdtbh->pump;
    $bdtbh->finish;

    # Could make this pretty cool by printing last line of $vivado_out
    # until vivado exits, maybe
    $vivadoSTDIN = "exit 1\n";
    $vivadoh->pump;
    $vivadoh->finish;

}
# Kick off the vivado and questa simulations in parallel
# Inputs
# Working dir
#  this is the dir where vivado and bdtb will be launched from
#
sub run_simulations {

    my ($work_dir) = @_;

    # CD to a dir
    print ("work_dir: $work_dir\n");
    chdir ("$work_dir");

    # Create the output files, so that the pre-commit-screen.sh script
    # will be able to tail -f them even before the simulations have
    # begun running
    open (OF, ">", $bdtb_out );
    close (OF);
    open (OF, ">", $vivado_out);
    close (OF);

    # Register handler so we can cancel the script if needed
    $SIG{INT} = \&handler;

    print ("Starting bdtb\n");
    my @cmd1 = ("bdtb");
    $bdtbh = start (\@cmd1, \$bdtbSTDIN, ">&", $bdtb_out);

    my $HOME = $ENV{"HOME"};
    my @cmd2 = ("vivado", "-notrace", "-nolog", "-nojournal", "-mode",
                "tcl", "-source",
                "$HOME/scripts/run_vivado_sim_top_tb.tcl");
    #my @cmd2 = ("vivado", "-help");

    # Wait for bdtb to clear out of the vivado build state
    # TODO, watch bdtb_out file for signs that Vivado build has completed
    sleep (180);
    print ("Starting vivado\n");
    $vivadoh = start (\@cmd2, \$vivadoSTDIN, ">&", $vivado_out);

    # Join
    print ("waiting on simulations\n");
    $bdtbh->finish;
    print ("bdtb complete\n");
    $vivadoh->finish;
    print ("vivado complete\n");
    print ("done waiting\n");
}

# open file
# read a line
# look for exact string match
# on first match, write line plus next to output file
# continue to next line
#
# Inputs
# Array of Files (ref)
# Array of strings (ref)
# output file name
#
# Outputs
sub filter_file_for_strings {

    my ($inFiles, $strings, $outFile) = @_;

    foreach my $inFile (@$inFiles) {

        print ("inFile: $inFile\n");
        print ("outFile: $outFile\n");

        # Open the input file
        open (IF, '<', $inFile) or die $!;

        # Open the output file
        open (OF, '>>', $outFile) or die $!;

        # While read line
        while (<IF>) {

            # If this line has 'warning' on it, then test for strings
            if (/warning/i) {

                #print (OF "\n");

                # Test every string against this line, if match, print the
                # line to outFile
                foreach my $string (@$strings) {

                    #print (OF "$string\n");

                    # Modify string so that the '.' matches on period only
                    my $tstring = $string;
                    $tstring  =~ s/[.]/[\.]/;
                    #print (OF "$tstring\n");

                    if (/$tstring/) {

                        # Print a separator
                        print (OF "--\n");
                        print (OF "File   : $inFile\n");
                        print (OF "Matched: $tstring\n");
                        print (OF);

                        # Print the following line as well
                        my $nextLine = <IF>;
                        print (OF $nextLine);

                        #next;

                    } # end if match

                } # end foreach $string

            } # end unless
        }

        # Close input file
        close (IF);

        # Print a separator
        print (OF "-- End $inFile\n");

        # Close output file
        close (OF);

    } # end foreach inFile

    # Display final results, from all input files that were filtered
    open (OF, '<', $outFile) or die $!;
    while (<OF>) {
        print;
    }
    close(OF);

    # Delete the temporary output file
    unlink($outFile) or die "Can't delete $outFile: $!\n";
}

# Inputs
# Path
#
# Outputs
# Array of file names
sub get_files_under_path {
    my $path = shift;
    #print ("ENTER: get_files_under_dir\n");

    #my @files = `ls -r $path`;
    my $output = `find \$PWS/FPGA/security/hdl -type f -printf "%f "`;
    my @files = split (" ", $output);
    #print ("files: @files\n");

    return @files;
}

# Kick off the vivado and questa simulations in parallel
&run_simulations($PWS);

# Get list of strings by reading security/ directory for file names
my @fileNames = &get_files_under_path ("\${PWS}/FPGA/security/hdl");

# Filter the logs
my @logs = ("$bdtb_out", "$vivado_out");
&filter_file_for_strings (\@logs, \@fileNames, $TMP_FILE0);
